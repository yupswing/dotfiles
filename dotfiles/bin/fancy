#!/usr/bin/env ruby

# FancyFont v1.2
# (c) 2025 Simone Cingano
# This program is free software: you can redistribute it and/or modify

# ------------------------------------------------------------------------------
# This script converts a string into different fancy fonts using Unicode characters.

# ORIGINAL INFO
# https://en.wikipedia.org/wiki/Mathematical_Alphanumeric_Symbols

# TEST
# ./fancy.rb --help
# ./fancy.rb 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'
# ------------------------------------------------------------------------------

class FancyFont
  # ============================================================================
  # Utility Methods

  # Converts an integer to a UTF-8 character.
  #
  # @param int [Integer]
  # @return [String]
  def self.c(int)
    int.chr('UTF-8')
  end

  def c(int)
    self.class.c(int)
  end

  # ============================================================================
  # Configuration Constants

  # Base codepoints for each character category.
  BASE_CODEPOINTS = [
    0x00041, # 'A' uppercase
    0x00061, # 'a' lowercase
    0x00030  # '0' digits
  ].freeze

  # Font database.
  # pass: true means no conversion is needed
  # table: the standard table to be used, 62 characters A-Z, a-z, 0-9
  # generator: instead of the table, a generator is used to create the font
  #   map: [start_uppercase, start_lowercase, start_digits] (optional, nil for no mapping)
  #   exceptions: a hash with exceptions for specific characters
  #   decorators: an array with two elements for zero-width joiners (optional)
  DB = {
    'serif-normal' => {
      pass: true
      # table: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'.chars,
      # generator: {
      #   map: [nil, nil, nil], # default, no need to convert
      #   exceptions: nil
      # }
    },
    'serif-bold' => {
      # table: 'ð€ðð‚ðƒð„ð…ð†ð‡ðˆð‰ðŠð‹ðŒððŽððð‘ð’ð“ð”ð•ð–ð—ð˜ð™ðšð›ðœððžðŸð ð¡ð¢ð£ð¤ð¥ð¦ð§ð¨ð©ðªð«ð¬ð­ð®ð¯ð°ð±ð²ð³ðŸŽðŸðŸðŸ‘ðŸ’ðŸ“ðŸ”ðŸ•ðŸ–ðŸ—'.chars
      generator: {
        map: [0x1D400, 0x1D41A, 0x1D7CE],
        exceptions: nil
      }
    },
    'serif-italic' => {
      # table: 'ð´ðµð¶ð·ð¸ð¹ðºð»ð¼ð½ð¾ð¿ð‘€ð‘ð‘‚ð‘ƒð‘„ð‘…ð‘†ð‘‡ð‘ˆð‘‰ð‘Šð‘‹ð‘Œð‘ð‘Žð‘ð‘ð‘‘ð‘’ð‘“ð‘”â„Žð‘–ð‘—ð‘˜ð‘™ð‘šð‘›ð‘œð‘ð‘žð‘Ÿð‘ ð‘¡ð‘¢ð‘£ð‘¤ð‘¥ð‘¦ð‘§0123456789'.chars
      generator: {
        map: [0x1D434, 0x1D44E, nil],
        exceptions: {
          'h' => c(0x0210E)
        }
      }
    },
    'serif-bold-italic' => {
      # table: 'ð‘¨ð‘©ð‘ªð‘«ð‘¬ð‘­ð‘®ð‘¯ð‘°ð‘±ð‘²ð‘³ð‘´ð‘µð‘¶ð‘·ð‘¸ð‘¹ð‘ºð‘»ð‘¼ð‘½ð‘¾ð‘¿ð’€ð’ð’‚ð’ƒð’„ð’…ð’†ð’‡ð’ˆð’‰ð’Šð’‹ð’Œð’ð’Žð’ð’ð’‘ð’’ð’“ð’”ð’•ð’–ð’—ð’˜ð’™ð’šð’›0123456789'.chars
      generator: {
        map: [0x1D468, 0x1D482, nil],
        exceptions: nil
      }
    },
    'sans-serif-normal' => {
      # table: 'ð– ð–¡ð–¢ð–£ð–¤ð–¥ð–¦ð–§ð–¨ð–©ð–ªð–«ð–¬ð–­ð–®ð–¯ð–°ð–±ð–²ð–³ð–´ð–µð–¶ð–·ð–¸ð–¹ð–ºð–»ð–¼ð–½ð–¾ð–¿ð—€ð—ð—‚ð—ƒð—„ð—…ð—†ð—‡ð—ˆð—‰ð—Šð—‹ð—Œð—ð—Žð—ð—ð—‘ð—’ð—“ðŸ¢ðŸ£ðŸ¤ðŸ¥ðŸ¦ðŸ§ðŸ¨ðŸ©ðŸªðŸ«'.chars
      generator: {
        map: [0x1D5A0, 0x1D5BA, 0x1D7E2],
        exceptions: nil
      }
    },
    'sans-serif-bold' => {
      # table: 'ð—”ð—•ð—–ð——ð—˜ð—™ð—šð—›ð—œð—ð—žð—Ÿð— ð—¡ð—¢ð—£ð—¤ð—¥ð—¦ð—§ð—¨ð—©ð—ªð—«ð—¬ð—­ð—®ð—¯ð—°ð—±ð—²ð—³ð—´ð—µð—¶ð—·ð—¸ð—¹ð—ºð—»ð—¼ð—½ð—¾ð—¿ð˜€ð˜ð˜‚ð˜ƒð˜„ð˜…ð˜†ð˜‡ðŸ¬ðŸ­ðŸ®ðŸ¯ðŸ°ðŸ±ðŸ²ðŸ³ðŸ´ðŸµ'.chars
      generator: {
        map: [0x1D5D4, 0x1D5EE, 0x1D7EC],
        exceptions: nil
      }
    },
    'sans-serif-italic' => {
      # table: 'ð˜ˆð˜‰ð˜Šð˜‹ð˜Œð˜ð˜Žð˜ð˜ð˜‘ð˜’ð˜“ð˜”ð˜•ð˜–ð˜—ð˜˜ð˜™ð˜šð˜›ð˜œð˜ð˜žð˜Ÿð˜ ð˜¡ð˜¢ð˜£ð˜¤ð˜¥ð˜¦ð˜§ð˜¨ð˜©ð˜ªð˜«ð˜¬ð˜­ð˜®ð˜¯ð˜°ð˜±ð˜²ð˜³ð˜´ð˜µð˜¶ð˜·ð˜¸ð˜¹ð˜ºð˜»ðŸ¢ðŸ£ðŸ¤ðŸ¥ðŸ¦ðŸ§ðŸ¨ðŸ©ðŸªðŸ«'.chars
      generator: {
        map: [0x1D608, 0x1D622, 0x1D7E2],
        exceptions: nil
      }
    },
    'sans-serif-bold-italic' => {
      # table: 'ð˜¼ð˜½ð˜¾ð˜¿ð™€ð™ð™‚ð™ƒð™„ð™…ð™†ð™‡ð™ˆð™‰ð™Šð™‹ð™Œð™ð™Žð™ð™ð™‘ð™’ð™“ð™”ð™•ð™–ð™—ð™˜ð™™ð™šð™›ð™œð™ð™žð™Ÿð™ ð™¡ð™¢ð™£ð™¤ð™¥ð™¦ð™§ð™¨ð™©ð™ªð™«ð™¬ð™­ð™®ð™¯ðŸ¢ðŸ£ðŸ¤ðŸ¥ðŸ¦ðŸ§ðŸ¨ðŸ©ðŸªðŸ«'.chars
      generator: {
        map: [0x1D63C, 0x1D656, 0x1D7E2],
        exceptions: nil
      }
    },
    'calligraphy-normal' => {
      # table: 'ð’œâ„¬ð’žð’Ÿâ„°â„±ð’¢â„‹â„ð’¥ð’¦â„’â„³ð’©ð’ªð’«ð’¬â„›ð’®ð’¯ð’°ð’±ð’²ð’³ð’´ð’µð’¶ð’·ð’¸ð’¹â„¯ð’»â„Šð’½ð’¾ð’¿ð“€ð“ð“‚ð“ƒâ„´ð“…ð“†ð“‡ð“ˆð“‰ð“Šð“‹ð“Œð“ð“Žð“0123456789'.chars
      generator: {
        map: [0x1D49C, 0x1D4B6, nil],
        exceptions: {
          'B' => c(0x0212C), 'E' => c(0x02130), 'F' => c(0x02131),
          'H' => c(0x0210B), 'I' => c(0x02110), 'L' => c(0x02112),
          'M' => c(0x02133), 'R' => c(0x0211B),
          'e' => c(0x0212F), 'g' => c(0x0210A), 'o' => c(0x02134)
        }
      }
    },
    'calligraphy-bold' => {
      # table: 'ð“ð“‘ð“’ð““ð“”ð“•ð“–ð“—ð“˜ð“™ð“šð“›ð“œð“ð“žð“Ÿð“ ð“¡ð“¢ð“£ð“¤ð“¥ð“¦ð“§ð“¨ð“©ð“ªð“«ð“¬ð“­ð“®ð“¯ð“°ð“±ð“²ð“³ð“´ð“µð“¶ð“·ð“¸ð“¹ð“ºð“»ð“¼ð“½ð“¾ð“¿ð”€ð”ð”‚ð”ƒ0123456789'.chars
      generator: {
        map: [0x1D4D0, 0x1D4EA, nil],
        exceptions: nil
      }
    },

    'franktur-normal' => {
      # table: 'ð”„ð”…â„­ð”‡ð”ˆð”‰ð”Šâ„Œâ„‘ð”ð”Žð”ð”ð”‘ð”’ð”“ð””â„œð”–ð”—ð”˜ð”™ð”šð”›ð”œâ„¨ð”žð”Ÿð” ð”¡ð”¢ð”£ð”¤ð”¥ð”¦ð”§ð”¨ð”©ð”ªð”«ð”¬ð”­ð”®ð”¯ð”°ð”±ð”²ð”³ð”´ð”µð”¶ð”·0123456789'.chars
      generator: {
        map: [0x1D504, 0x1D51E, nil],
        exceptions: {
          'C' => c(0x0212D), 'H' => c(0x0210C), 'I' => c(0x02111),
          'R' => c(0x0211C), 'Z' => c(0x02128)
        }
      }
    },
    'fraktur-bold' => {
      # table: 'ð•¬ð•­ð•®ð•¯ð•°ð•±ð•²ð•³ð•´ð•µð•¶ð•·ð•¸ð•¹ð•ºð•»ð•¼ð•½ð•¾ð•¿ð–€ð–ð–‚ð–ƒð–„ð–…ð–†ð–‡ð–ˆð–‰ð–Šð–‹ð–Œð–ð–Žð–ð–ð–‘ð–’ð–“ð–”ð–•ð––ð–—ð–˜ð–™ð–šð–›ð–œð–ð–žð–Ÿ0123456789'.chars
      generator: {
        map: [0x1D56C, 0x1D586, nil],
        exceptions: nil
      }
    },
    'monospace-normal' => {
      # table: 'ð™°ð™±ð™²ð™³ð™´ð™µð™¶ð™·ð™¸ð™¹ð™ºð™»ð™¼ð™½ð™¾ð™¿ðš€ðšðš‚ðšƒðš„ðš…ðš†ðš‡ðšˆðš‰ðšŠðš‹ðšŒðšðšŽðšðšðš‘ðš’ðš“ðš”ðš•ðš–ðš—ðš˜ðš™ðššðš›ðšœðšðšžðšŸðš ðš¡ðš¢ðš£ðŸ¶ðŸ·ðŸ¸ðŸ¹ðŸºðŸ»ðŸ¼ðŸ½ðŸ¾ðŸ¿'.chars
      generator: {
        map: [0x1D670, 0x1D68A, 0x1D7F6],
        exceptions: nil
      }
    },
    'double-struck-normal' => {
      # table: 'ð”¸ð”¹â„‚ð”»ð”¼ð”½ð”¾â„ð•€ð•ð•‚ð•ƒð•„â„•ð•†â„™â„šâ„ð•Šð•‹ð•Œð•ð•Žð•ð•â„¤ð•’ð•“ð•”ð••ð•–ð•—ð•˜ð•™ð•šð•›ð•œð•ð•žð•Ÿð• ð•¡ð•¢ð•£ð•¤ð•¥ð•¦ð•§ð•¨ð•©ð•ªð•«ðŸ˜ðŸ™ðŸšðŸ›ðŸœðŸðŸžðŸŸðŸ ðŸ¡'.chars
      generator: {
        map: [0x1D538, 0x1D552, 0x1D7D8],
        exceptions: {
          'C' => c(0x02102), 'H' => c(0x0210D), 'N' => c(0x02115),
          'P' => c(0x02119), 'Q' => c(0x0211A), 'R' => c(0x0211D),
          'Z' => c(0x02124)
        }
      }
    },
    'circled' => {
      # table: 'â’¶â’·â’¸â’¹â’ºâ’»â’¼â’½â’¾â’¿â“€â“â“‚â“ƒâ“„â“…â“†â“‡â“ˆâ“‰â“Šâ“‹â“Œâ“â“Žâ“â“â“‘â“’â““â“”â“•â“–â“—â“˜â“™â“šâ“›â“œâ“â“žâ“Ÿâ“ â“¡â“¢â“£â“¤â“¥â“¦â“§â“¨â“©ðŸ„‹â‘ â‘¡â‘¢â‘£â‘¤â‘¥â‘¦â‘§â‘¨'.chars
      generator: {
        map: [0x024B6, 0x024D0, 0x0245f],
        exceptions: {
          '0' => c(0x1f10b)
        }
      }
    },
    'circled-dark' => {
      # table: 'ðŸ…ðŸ…‘ðŸ…’ðŸ…“ðŸ…”ðŸ…•ðŸ…–ðŸ…—ðŸ…˜ðŸ…™ðŸ…šðŸ…›ðŸ…œðŸ…ðŸ…žðŸ…ŸðŸ… ðŸ…¡ðŸ…¢ðŸ…£ðŸ…¤ðŸ…¥ðŸ…¦ðŸ…§ðŸ…¨ðŸ…©ðŸ…ðŸ…‘ðŸ…’ðŸ…“ðŸ…”ðŸ…•ðŸ…–ðŸ…—ðŸ…˜ðŸ…™ðŸ…šðŸ…›ðŸ…œðŸ…ðŸ…žðŸ…ŸðŸ… ðŸ…¡ðŸ…¢ðŸ…£ðŸ…¤ðŸ…¥ðŸ…¦ðŸ…§ðŸ…¨ðŸ…©â“¿â¶â·â¸â¹âºâ»â¼â½â¾'.chars
      generator: {
        map: [0x1f150, 0x1f150, 0x02775],
        exceptions: {
          '0' => c(0x024ff)
        }
      }
    },
    'boxed' => {
      # table: 'ðŸ„°ðŸ„±ðŸ„²ðŸ„³ðŸ„´ðŸ„µðŸ„¶ðŸ„·ðŸ„¸ðŸ„¹ðŸ„ºðŸ„»ðŸ„¼ðŸ„½ðŸ„¾ðŸ„¿ðŸ…€ðŸ…ðŸ…‚ðŸ…ƒðŸ…„ðŸ……ðŸ…†ðŸ…‡ðŸ…ˆðŸ…‰ðŸ„°ðŸ„±ðŸ„²ðŸ„³ðŸ„´ðŸ„µðŸ„¶ðŸ„·ðŸ„¸ðŸ„¹ðŸ„ºðŸ„»ðŸ„¼ðŸ„½ðŸ„¾ðŸ„¿ðŸ…€ðŸ…ðŸ…‚ðŸ…ƒðŸ…„ðŸ……ðŸ…†ðŸ…‡ðŸ…ˆðŸ…‰0123456789'.chars
      generator: {
        map: [0x1F130, 0x1F130, nil],
        exceptions: nil
      }
    },
    'boxed-dark' => {
      # SOME LETTERS CAN APPEAR AS EMOJI IN SOME CONTEXT (A, O, P...)
      # table: 'ðŸ…°ðŸ…±ðŸ…²ðŸ…³ðŸ…´ðŸ…µðŸ…¶ðŸ…·ðŸ…¸ðŸ…¹ðŸ…ºðŸ…»ðŸ…¼ðŸ…½ðŸ…¾ðŸ…¿ðŸ†€ðŸ†ðŸ†‚ðŸ†ƒðŸ†„ðŸ†…ðŸ††ðŸ†‡ðŸ†ˆðŸ†‰ðŸ…°ðŸ…±ðŸ…²ðŸ…³ðŸ…´ðŸ…µðŸ…¶ðŸ…·ðŸ…¸ðŸ…¹ðŸ…ºðŸ…»ðŸ…¼ðŸ…½ðŸ…¾ðŸ…¿ðŸ†€ðŸ†ðŸ†‚ðŸ†ƒðŸ†„ðŸ†…ðŸ††ðŸ†‡ðŸ†ˆðŸ†‰0123456789'.chars
      generator: {
        map: [0x1F170, 0x1F170, nil],
        exceptions: nil
      }
    },
    'squared' => {
      # table: 'ðŸ„ðŸ„‘ðŸ„’ðŸ„“ðŸ„”ðŸ„•ðŸ„–ðŸ„—ðŸ„˜ðŸ„™ðŸ„šðŸ„›ðŸ„œðŸ„ðŸ„žðŸ„ŸðŸ„ ðŸ„¡ðŸ„¢ðŸ„£ðŸ„¤ðŸ„¥ðŸ„¦ðŸ„§ðŸ„¨ðŸ„©ðŸ„ðŸ„‘ðŸ„’ðŸ„“ðŸ„”ðŸ„•ðŸ„–ðŸ„—ðŸ„˜ðŸ„™ðŸ„šðŸ„›ðŸ„œðŸ„ðŸ„žðŸ„ŸðŸ„ ðŸ„¡ðŸ„¢ðŸ„£ðŸ„¤ðŸ„¥ðŸ„¦ðŸ„§ðŸ„¨ðŸ„©0123456789'.chars
      generator: {
        map: [0x1f110, 0x1f110, nil]
      }
    },
    'fullwidth' => {
      # table: 'ï¼¡ï¼¢ï¼£ï¼¤ï¼¥ï¼¦ï¼§ï¼¨ï¼©ï¼ªï¼«ï¼¬ï¼­ï¼®ï¼¯ï¼°ï¼±ï¼²ï¼³ï¼´ï¼µï¼¶ï¼·ï¼¸ï¼¹ï¼ºï½ï½‚ï½ƒï½„ï½…ï½†ï½‡ï½ˆï½‰ï½Šï½‹ï½Œï½ï½Žï½ï½ï½‘ï½’ï½“ï½”ï½•ï½–ï½—ï½˜ï½™ï½šï¼ï¼‘ï¼’ï¼“ï¼”ï¼•ï¼–ï¼—ï¼˜ï¼™'.chars
      generator: {
        map: [0x0ff21, 0x0ff41, 0x0ff10],
        exceptions: nil
      }
    },
    'emoji' => {
      table: ['ðŸ”º', 'ðŸŽ±', 'ðŸŒœ', 'ðŸŒ“', 'ðŸ“§', 'ðŸŽ', 'ðŸŒ€', 'â™“', 'ðŸ“', 'ðŸŽ·', 'ðŸŽ‹', 'ðŸ“', 'â™', 'ðŸŽµ', 'âš½', 'ðŸš©', 'ðŸ³', 'ðŸƒ', 'ðŸ’²', 'ðŸŒ´', 'â›Ž', 'âœ…', 'ðŸ”±', 'âŽ', 'ðŸ¸', 'ðŸ’¤',
              'ðŸ”º', 'ðŸŽ±', 'ðŸŒœ', 'ðŸŒ“', 'ðŸ“§', 'ðŸŽ', 'ðŸŒ€', 'â™“', 'ðŸ“', 'ðŸŽ·', 'ðŸŽ‹', 'ðŸ“', 'â™', 'ðŸŽµ', 'âš½', 'ðŸš©', 'ðŸ³', 'ðŸƒ', 'ðŸ’²', 'ðŸŒ´', 'â›Ž', 'âœ…', 'ðŸ”±', 'âŽ', 'ðŸ¸', 'ðŸ’¤',
              '0', '1', '2', '3', '4', '5', '6', '7', '8', '9']
    },
    'emoji-regional' => {
      # USE REGIONAL INDICATOR EMOJI TO WRITE LETTERS, SOMETIMES THEY ARE NOT SUPPORTED
      generator: {
        map: [0x1F1E6, 0x1F1E6, nil],
        decorators: ['', c(0x0200C)], # Zero Width Non-Joiner (U+200C)
        exceptions: nil
      }
    },
    'smallcaps' => {
      # alternatives for Q: êž¯Ç«
      table: 'ABCDEFGHIJKLMNOPQRSTUVWXYZá´€Ê™á´„á´…á´‡êœ°É¢ÊœÉªá´Šá´‹ÊŸá´É´á´á´˜Ç«Ê€êœ±á´›á´œá´ á´¡xÊá´¢0123456789'
    },
    'subscript' => {
      table: 'â‚áµ¦ð’¸ð’¹â‚‘ð’»ð“°â‚•áµ¢â±¼â‚–â‚—â‚˜â‚™â‚’â‚šð“ºáµ£â‚›â‚œáµ¤áµ¥ð“Œâ‚“áµ§ð“â‚áµ¦ð’¸ð’¹â‚‘ð’»ð“°â‚•áµ¢â±¼â‚–â‚—â‚˜â‚™â‚’â‚šð“ºáµ£â‚›â‚œáµ¤áµ¥ð“Œâ‚“áµ§ð“â‚€â‚â‚‚â‚ƒâ‚„â‚…â‚†â‚‡â‚ˆâ‚‰'
    },
    'superscript' => {
      table: 'á´¬á´®êŸ²á´°á´±êŸ³á´³á´´á´µá´¶á´·á´¸á´¹á´ºá´¼á´¾êŸ´á´¿Ë¢áµ€áµâ±½áµ‚áµ¡ðž²á™†áµƒáµ‡á¶œáµˆáµ‰á¶ áµÊ°â±Ê²áµË¡áµâ¿áµ’áµ–ðž¥Ê³Ë¢áµ—áµ˜áµ›Ê·Ë£Ê¸á¶»â°Â¹Â²Â³â´âµâ¶â·â¸â¹'
    },
    'crazy1' => {
      table: 'Ã„ÃŸÃ‡ÃÃˆÂ£GHÃŒJKLMÃ±Ã–Ã¾QRÂ§â€ ÃšVWÃ—Â¥ZÃ¥ÃŸÂ¢ÃÃªÂ£ghÃ¯jklmÃ±Ã°Ã¾qrÂ§â€ ÂµvwxÂ¥z0123456789'
    },
    'crazy2' => {
      table: 'á—©á—·á‘•á—ªEá–´Gá•¼Iá’Ká’ªá—°á‘ŽOá‘­á‘«á–‡á”•Tá‘Œá¯á—¯á™­Yá˜”á—©á—·á‘•á—ªEá–´Gá•¼Iá’Ká’ªá—°á‘ŽOá‘­á‘«á–‡á”•Tá‘Œá¯á—¯á™­Yá˜”0123456789'
    },
    'crazy3' => {
      table: 'ÇŸÉ®ÆˆÉ–É›Ê„É¢É¦É¨ÊÓ„ÊŸÊÕ¼Ö…Ö„Õ¦Ê€Ö†È¶ÊŠÊ‹Õ¡Ó¼ÊÊÇŸÉ®ÆˆÉ–É›Ê„É¢É¦É¨ÊÓ„ÊŸÊÕ¼Ö…Ö„Õ¦Ê€Ö†È¶ÊŠÊ‹Õ¡Ó¼ÊÊ0123456789'
    }
  }.freeze

  FONTS_SHORTCUTS = {
    'sb' => 'serif-bold',
    'si' => 'serif-italic',
    'sbi' => 'serif-bold-italic',
    'ss' => 'sans-serif-normal',
    'ssb' => 'sans-serif-bold',
    'ssi' => 'sans-serif-italic',
    'ssbi' => 'sans-serif-bold-italic',
    'c' => 'calligraphy-normal',
    'cb' => 'calligraphy-bold',
    'f' => 'franktur-normal',
    'fb' => 'fraktur-bold',
    'm' => 'monospace-normal',
    'ds' => 'double-struck-normal',
    'o' => 'circled',
    'od' => 'circled-dark',
    'b' => 'boxed',
    'bd' => 'boxed-dark',
    's' => 'squared',
    'fw' => 'fullwidth',
    'e' => 'emoji',
    'er' => 'emoji-regional',
    'sc' => 'smallcaps',
    'sub' => 'subscript',
    'sup' => 'superscript'
  }

  # List of available fonts
  FONTS = DB.keys.freeze

  # Standard character table
  STANDARD_TABLE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'.freeze

  # ============================================================================
  # Instance Variables

  attr_reader :font, :table

  # ============================================================================

  # Initializes a new FancyFont instance.
  #
  # @param font [String] one of the keys from FONTS
  # @raise [ArgumentError] if the font is not available
  def initialize(font)
    @font = find_font(font)
    @table = DB[@font][:table] || generate_table(STANDARD_TABLE)

    raise 'Table is not defined as 62 chars as expected' if @table && @table.size != 62
  end

  # Translate the given string into the target font.
  #
  # @param text [String] the text to be translated
  # @return [String] the translated text
  def translate(text)
    return text if @table.nil?

    text.chars.map { |char| translate_char(char) }.join
  end

  def font_label
    return @font_label if @font_label

    shortcut = FONTS_SHORTCUTS.find { |_, v| v == font }&.first
    @font_label = if shortcut
                    "#{@font} (#{shortcut})"
                  else
                    @font
                  end
  end

  # ============================================================================

  # Returns an array of arrays with each character and its Unicode code (in hex).
  #
  # @param string [String] the input text
  # @return [Array<Array(String, String)>]
  def self.debug_unicode(text)
    text.chars.map { |char| [char, "0x#{char.ord.to_s(16)}"] }
  end

  # Returns an array of available fonts.
  #
  # @return [Array<String>]
  def self.available_fonts
    FONTS
  end

  # ============================================================================
  # Internal Methods

  private

  def find_font(font)
    font = FONTS_SHORTCUTS[font] if FONTS_SHORTCUTS.key?(font)
    raise ArgumentError, "Font not found: #{font}" unless FONTS.include?(font)

    font
  end

  # Generates a transformation table by applying the generator to a standard table.
  #
  # @param source [String] the source characters to map
  # @return [Array<String>] an array with the transformed characters
  # @raise [RuntimeError] if no generator is defined for the font
  def generate_table(source)
    return nil if DB[@font][:pass]
    raise "No generator defined for font #{@font}" unless DB[@font].key?(:generator)

    source.chars.map { |char| translate_char_live(char) }
  end

  # Determines the category of the character: uppercase, lowercase, or digit.
  #
  # @param char [String] the character to check
  # @return Integer returns an index (0 for uppercase, 1 for lowercase, 2 for digit, or nil if no match)
  def char_to_category(char)
    ord = char.ord
    case ord
    when BASE_CODEPOINTS[0]...BASE_CODEPOINTS[0] + 26 # uppercase
      0
    when BASE_CODEPOINTS[1]...BASE_CODEPOINTS[1] + 26 # lowercase
      1
    when BASE_CODEPOINTS[2]...BASE_CODEPOINTS[2] + 10 # digit
      2
    end
  end

  # Translates a single character using a pre-generated lookup table.
  #
  # @param char [String] the character to translate
  # @return [String] the translated character or the original if out of range
  def translate_char(char)
    category = char_to_category(char)
    return char unless category

    # Calculate the index in the pre-generated table.
    table_index =
      case category
      when 0 then char.ord - BASE_CODEPOINTS[category]
      when 1 then 26 + (char.ord - BASE_CODEPOINTS[category])
      when 2 then 52 + (char.ord - BASE_CODEPOINTS[category])
      end

    @table[table_index] || char
  end

  # Translates a single character on the fly using the font's generator.
  #
  # @param char [String] the character to translate
  # @return [String] the decorated, translated character or the original if no mapping exists
  def translate_char_live(char)
    category = char_to_category(char)
    return char unless category

    generator = DB[@font][:generator]

    # Handle any exceptions.
    return decorate(generator[:exceptions][char]) if generator[:exceptions]&.key?(char)

    mapping_start = generator[:map][category]
    return char if mapping_start.nil?

    new_codepoint = mapping_start + (char.ord - BASE_CODEPOINTS[category])
    decorate(c(new_codepoint))
  end

  # Decorates the character if decorators are defined for the current font.
  # (decorators are other characters that are added before and after the character)
  #
  # @param str [String] the character to decorate
  # @return [String] the decorated character
  def decorate(str)
    decorators = DB[@font][:generator][:decorators]
    return str unless decorators

    "#{decorators[0]}#{str}#{decorators[1]}"
  end
end

# ==============================================================================

# Print help message if no arguments or if -h/--help is present
if ARGV.empty? || ARGV.include?('-h') || ARGV.include?('--help')

  fonts = FancyFont.available_fonts.map do |font|
    f = FancyFont.new(font)
    "#{f.font_label.ljust(30)}#{f.translate(FancyFont::STANDARD_TABLE)}"
  end

  puts <<~HELP
    Usage:
     ./fancy.rb --help                       Print this help message and exit.
     ./fancy.rb <font-name> <string>         Translate a string using a specific font.
     ./fancy.rb <string>                     Demo mode: translate a string in all fonts.
     cat file.txt | ./fancy.rb <font-name>   Translate an input from STDIN.

    Available fonts:
     - #{fonts.join("\n - ")}
  HELP
  exit 0
end

if ARGV[0] == '-d'
  # Debug mode: print the Unicode codepoints of the input string.
  pp FancyFont.debug_unicode(ARGV[1..].join(' '))
elsif !STDIN.tty?
  # Piped input, the first argument is assumed to be the font.
  font = ARGV[0]
  text = STDIN.read.chomp
  puts FancyFont.new(font).translate(text)
elsif ARGV.size == 1
  # No piped input, one argument is treated as text to be translated in all fonts.
  text = ARGV[0]
  FancyFont.available_fonts.each do |font|
    f = FancyFont.new(font)
    puts " - #{f.font_label.ljust(30)} #{f.translate(text)}"
  end
else
  # Direct translation mode: first argument is the font and the rest is the string.
  font = ARGV.shift
  text = ARGV.join(' ')
  puts FancyFont.new(font).translate(text)
end
